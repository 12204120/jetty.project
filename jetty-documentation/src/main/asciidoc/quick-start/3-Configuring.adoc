//
//  ========================================================================
//  Copyright (c) 1995-2018 Mort Bay Consulting Pty. Ltd.
//  ========================================================================
//  All rights reserved. This program and the accompanying materials
//  are made available under the terms of the Eclipse Public License v1.0
//  and Apache License v2.0 which accompanies this distribution.
//
//      The Eclipse Public License is available at
//      http://www.eclipse.org/legal/epl-v10.html
//
//      The Apache License v2.0 is available at
//      http://www.opensource.org/licenses/apache2.0.php
//
//  You may elect to redistribute this code under either of these licenses.
//  ========================================================================
//

[[quickstart-config-how]]
=== How to Configure Jetty

To understand Jetty configuration, you need to understand the "How" and the "What".
This section covers how to configure Jetty in terms of what mechanisms exist to perform configuration.
The link:#quickstart-config-what[next section] gives an overview of the action components and fields that you can configure with these mechanisms.

==== Jetty POJO Configuration

The core components of Jetty are Plain Old Java Objects (http://en.wikipedia.org/wiki/Plain_Old_Java_Object[POJOs])
The process of configuring Jetty is mostly the process of instantiating, assembling and setting fields on the Jetty POJOs.
This can be achieved by:

* Writing Java code to directly instantiate and assemble Jetty objects.
This is referred to as xref:embedding-jetty[].
* Using Jetty XML configuration, which is an http://en.wikipedia.org/wiki/Inversion_of_Control[Inversion of Control (IoC)] framework, to instantiate and assemble Jetty objects as XML objects.
The `etc/jetty.xml` file is the main Jetty XML configuration file, but there are many other `etc/jetty-__feature__.xml` files included in the Jetty distribution.
* Using a third party http://en.wikipedia.org/wiki/Inversion_of_Control[IoC] framework like http://en.wikipedia.org/wiki/Spring_Framework[Spring], to instantiate and assemble Jetty objects as Spring beans.

Because the main Jetty configuration is done by IoC, the link:{JDURL}/[Jetty API documentation] is the ultimate configuration reference.

==== Jetty Start Configuration Files

The Jetty distribution uses the following configuration files to instantiate, inject and start server via the `start.jar` mechanism.

`ini` files::
  The Jetty Start mechanism uses the command line, the `$JETTY_BASE/start.ini` and/or `$JETTY_BASE/start.d/*.ini` files to create an effective command line of arguments.
  Arguments may be:

  * Module activations in the form `--module=name`
  * Properties in the form of `name=value`, used to parameterize Jetty IoC XML
  * XML files in Jetty IoC (or Spring) XML format
  * A standard http://en.wikipedia.org/wiki/Java_properties[Java property file] containing additional start properties
  * Other start.jar options (see `java -jar start.jar --help`)
  * Some JVM options in combination with `--exec`, such as `-Xbootclasspath`.

____
[NOTE]
--
It is the `ini` files located in the Jetty base directory (if different from Jetty home) that are typically edited to change the configuration (e.g. change ports). 
--
____

`mod` files::
  The `$JETTY_HOME/modules/*.mod` files contain the definition of modules that can be activated by `--module=name`.
  Each `mod` file defines:

  * Module dependencies for ordering and activation
  * The libraries needed by the module to be added to the classpath
  * The XML files needed by the module to be added to the effective command line
  * Files needed by the activated module
  * A template `ini` file to be used when activating the `--add-to-start=name` option
+
Typically module files are rarely edited and only then for significant structural changes.
The `*.mod` files are normally located in `$JETTY_HOME/modules/`, but extra or edited modules may be added to `$JETTY_BASE/module`.
If module changes are required, it is best practice to copy the particular `*.mod` file from `$JETTY_HOME/modules/` to `$JETTY_BASE/modules/` before being modified.

XML files::
  XML files in link:#jetty-xml-syntax[Jetty IoC XML format] or Spring IoC format are listed either on the command line, in `ini` files, or are added to the effective command line by a module definition.
  The XML files instantiate and inject the actual Java objects that comprise the server, connectors and contexts.
  Because Jetty IoC XML files use properties, most common configuration tasks can be accomplished without editing these XML files and can instead be achieved by editing the property in the corresponding `ini` files.
  XML files are normally located in `$JETTY_HOME/etc/`, but extra or edited XML files may be added to `$JETTY_BASE/etc/`.
  *Note* If XML configuration changes are required, it is best practice to copy the XML file from `$JETTY_HOME/etc/` to `$JETTY_BASE/etc/` before being modified.

Below is an illustration of how the various Jetty configuration files (`ini`, `mod` and XML) are related:

image:images/Jetty_Configuration_File_Relationships.png[image,width=693]

==== A Closer Look

To put it simply: XML files are responsible for instantiating the Jetty POJOs that make up the server.
They define properties which users can modify to meet the needs of their server.
These XML files are broken up by type in the distribution so they can be consumed as a user/server needs them.
For example, a server may need HTTP and HTTPS functionality, but opt out of using HTTP/2 and Websocket.

Module files allow users to enable and remove functionality quickly and easily from their server implementation.
They include a template of the different properties included in the associated XML file, as well as a pointer to the XML or JAR file(s) they are referencing.
When a module is activated these properties are added to a related `ini` file where users can configure them to meet their needs.
We will discuss modules in further detail in an upcoming chapter.

Ini files are where most users will spend the bulk of their time editing the configuration for their server.
As mentioned, they contain properties which were defined in their associated XML files which in turn reference Jetty Java objcts. 

This can be a bit overwhelming at first, so let's look at an example - in this case the `http` module.
We will work backwards from an ini file to the associated module and then the XML file in question.

First up, the `http.ini` file.
If we take a look at it's contents, we will see the following:

[source, screen, subs="{sub-order}"]
----
$ cat start.d/http.ini
# ---------------------------------------
# Module: http
# Enables a HTTP connector on the server.
# By default HTTP/1 is support, but HTTP2C can
# be added to the connector with the http2c module.
# ---------------------------------------
--module=http

### HTTP Connector Configuration

## Connector host/address to bind to
# jetty.http.host=0.0.0.0

## Connector port to listen on
# jetty.http.port=8080

## Connector idle timeout in milliseconds
# jetty.http.idleTimeout=30000

## Number of acceptors (-1 picks default based on number of cores)
# jetty.http.acceptors=-1

## Number of selectors (-1 picks default based on number of cores)
# jetty.http.selectors=-1

## ServerSocketChannel backlog (0 picks platform default)
# jetty.http.acceptorQueueSize=0

## Thread priority delta to give to acceptor threads
# jetty.http.acceptorPriorityDelta=0

## Reserve threads for high priority tasks (-1 use a heuristic, 0 no reserved threads)
# jetty.http.reservedThreads=-1

## Connect Timeout in milliseconds
# jetty.http.connectTimeout=15000

## HTTP Compliance: RFC7230, RFC2616, LEGACY
# jetty.http.compliance=RFC7230
----

So what do we see?
We have a module name, the module activation (`--module=http`), as well as a description and what look like properties to configure.
Those will some scripting/coding experience might notice that most of the lines are commented out with `#` and you'd be correct.
When a module is enabled and an `ini` file is created, all of the properties you see here were set to these defaults - the server is already using the values shown
If you wanted to change one of the properties though, say `jetty.http.port`, you'd simply uncomment the line and change the value.
For example:

[source, screen, subs="{sub-order}"]
----
$ cat start.d/http.ini
# ---------------------------------------
# Module: http
# Enables a HTTP connector on the server.
# By default HTTP/1 is support, but HTTP2C can
# be added to the connector with the http2c module.
# ---------------------------------------
--module=http

### HTTP Connector Configuration

## Connector host/address to bind to
# jetty.http.host=0.0.0.0

## Connector port to listen on
jetty.http.port=1234
...
----

As seen before, these properties were populated in this ini file based on a related module.
Standard Jetty modules live in the Home of the Jetty Distribution in the aptly named `modules` directory.
So let's take a quick look at the associated `$JETTY_HOME/modules/http.mod` file:

[source, screen, subs="{sub-order}"]
----
$ cat $JETTY_HOME/modules/http.mod
[description]
Enables a HTTP connector on the server.
By default HTTP/1 is support, but HTTP2C can
be added to the connector with the http2c module.

[tags]
connector
http

[depend]
server

[xml]
etc/jetty-http.xml

[ini-template]
### HTTP Connector Configuration

## Connector host/address to bind to
# jetty.http.host=0.0.0.0

## Connector port to listen on
# jetty.http.port=8080

## Connector idle timeout in milliseconds
# jetty.http.idleTimeout=30000
...
----
At first blush, it looks remarkable similar to the `ini` file we just looked at.
We still have a description and the properties we could edit, but now we also have several other sections.
These other sections will be looked at further in our chapter on modules, but for now it is worth noting the `[xml]` and `[ini-template]` sections.
As you could probably have puzzled out, the `[ini-template]` contains a template (go figure) for properties to be placed in the associated `ini` file when a module is activated.
The `[xml]` section refers to the file and location of the XML file these properties are based on. 
It is important to note that not every module file will have the same sections, but most should look structurally the same. 

Now that we know what XML file these properties relate to, we can navigate to it and have a look.

[source, xml, subs="{sub-order}"]
----
$ cat $JETTY_HOME/etc/jetty-http.xml
<?xml version="1.0"?>
<!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure_9_3.dtd">

<!-- ============================================================= -->
<!-- Configure the Jetty Server instance with an ID "Server"       -->
<!-- by adding a HTTP connector.                                   -->
<!-- This configuration must be used in conjunction with jetty.xml -->
<!-- ============================================================= -->
<Configure id="Server" class="org.eclipse.jetty.server.Server">

  <!-- =========================================================== -->
  <!-- Add a HTTP Connector.                                       -->
  <!-- Configure an o.e.j.server.ServerConnector with a single     -->
  <!-- HttpConnectionFactory instance using the common httpConfig  -->
  <!-- instance defined in jetty.xml                               -->
  <!--                                                             -->
  <!-- Consult the javadoc of o.e.j.server.ServerConnector and     -->
  <!-- o.e.j.server.HttpConnectionFactory for all configuration    -->
  <!-- that may be set here.                                       -->
  <!-- =========================================================== -->
  <Call name="addConnector">
    <Arg>
      <New id="httpConnector" class="org.eclipse.jetty.server.ServerConnector">
        <Arg name="server"><Ref refid="Server" /></Arg>
        <Arg name="acceptors" type="int"><Property name="jetty.http.acceptors" deprecated="http.acceptors" default="-1"/></Arg>
        <Arg name="selectors" type="int"><Property name="jetty.http.selectors" deprecated="http.selectors" default="-1"/></Arg>
        <Arg name="factories">
          <Array type="org.eclipse.jetty.server.ConnectionFactory">
            <Item>
              <New class="org.eclipse.jetty.server.HttpConnectionFactory">
                <Arg name="config"><Ref refid="httpConfig" /></Arg>
                <Arg name="compliance"><Call class="org.eclipse.jetty.http.HttpCompliance" name="valueOf"><Arg><Property name="jetty.http.compliance" default="RFC7230"/></Arg></Call></Arg>
              </New>
            </Item>
          </Array>
        </Arg>
        <Set name="host"><Property name="jetty.http.host" deprecated="jetty.host" /></Set>
        <Set name="port"><Property name="jetty.http.port" deprecated="jetty.port" default="8080" /></Set>
        <Set name="idleTimeout"><Property name="jetty.http.idleTimeout" deprecated="http.timeout" default="30000"/></Set>
        <Set name="acceptorPriorityDelta"><Property name="jetty.http.acceptorPriorityDelta" deprecated="http.acceptorPriorityDelta" default="0"/></Set>
        <Set name="acceptQueueSize"><Property name="jetty.http.acceptQueueSize" deprecated="http.acceptQueueSize" default="0"/></Set>
        <Get name="SelectorManager">
          <Set name="connectTimeout"><Property name="jetty.http.connectTimeout" default="15000"/></Set>
          <Set name="reservedThreads"><Property name="jetty.http.reservedThreads" default="-2"/></Set>
        </Get>
      </New>
    </Arg>
  </Call>

</Configure>
----

Now we can see where those properties in our `ini` and module files came from.
In Jetty XML files, Jetty objects come to life; defined properties are set which link back to the jar libraries and run the server to a user's specification.

____
[IMPORTANT]
It is important to remember that you should *not* modify the XML files in your `$JETTY_HOME`.
If you do for some reason feel you want to change the way an XML file operates, it is best to make a copy of it in your `$JETTY_BASE` in an `/etc` directory.
Jetty will always look first to the `$JETTY_BASE` for configuration.
____

==== Other Configuration Files

In addition to the configuration files described above, the configuration of the server can use the following file types:

Context XML files::
  Any XML files in link:#jetty-xml-syntax[Jetty IoC XML format] or Spring IoC format that is discovered in the `/webapps` directory are used by the deploy module to instantiate and inject `HttpContext` instances to create a specific context.
  These may be standard web applications or bespoke contexts created from special purpose handlers.

web.xml::
  The http://en.wikipedia.org/wiki/Servlet[Servlet] Specification defines the http://en.wikipedia.org/wiki/Web.xml[`web.xml`] deployment descriptor that defines and configures the filters, servlets and resources a http://en.wikipedia.org/wiki/Web_application[web application] uses.
  The Jetty `WebAppContext` component uses this XML format to:

  * Set up the default configuration of a web application context.
  * Interpret the application-specific configuration supplied with a web application in the `WEB-INF/web.xml` file.
  * Interpret descriptor fragments included in the `META-INF` directory of Jar files within `WEB-INF/lib.`
+
Normally the `web.xml` file for a web application is found in the `WEB-INF/web.xml` location within the war file/directory or as `web.xml` fragments with `.jar` files found in `WEB-INF/lib`.
Jetty also supports multiple `web.xml` files so that a default descriptor may be applied before `WEB-INF/web.xml` (typically set to `etc/webdefault.xml` by the deploy module) and an override descriptor may be applied after `WEB-INF/web.xml` (typically set by a context XML file see `test.xml`)

Property Files::
  Standard http://en.wikipedia.org/wiki/Java_properties[Java property files] are also used for Jetty configuration in several ways:
+
  * To parameterize Jetty IoC XML via the use of the `Property` element.
  * To configure the default logging mechanism (`StdErrLog`). Other logging frameworks can be utilized and also use property files (for example, `log4j`).
  * As a simple database for login usernames and credentials.

==== Jetty IoC XML format

To understand the link:#jetty-xml-syntax[Jetty IoC XML format], consider the following example of an embedded Jetty server instantiated and configured in Java:

[source, java, subs="{sub-order}"]
----
include::{SRCDIR}/examples/embedded/src/main/java/org/eclipse/jetty/embedded/ExampleServer.java[]
----

link:#jetty-xml-syntax[Jetty IoC XML format] allows you to instantiate and configure the exact same server in XML without writing any java code:

[source, xml, subs="{sub-order}"]
----
include::{SRCDIR}/examples/embedded/src/main/resources/exampleserver.xml[]
----

//In practice, most commonly used Jetty features have XML files that are included in the standard distribution in the `/etc` directory.
//Thus configuring Jetty is often a matter of just editing existing XML files and altering the property values injected into them.

[[quickstart-config-what]]
=== What to Configure in Jetty

This section gives an overview of the components of Jetty you typically configure using the mechanisms outlined in the previous section.
xref:basic-architecture[] describes the structure of a Jetty server, which is good background reading to understand configuration, and is vital if you want to change the structure of the server as set up by the default configurations in the Jetty distribution. 
However, for most purposes, configuration is a matter of identifying the correct configuration file and modifying existing configuration values.

[[intro-jetty-configuration-server]]
==== Configuring the Server

The Server instance is the central coordination object of a Jetty server; it provides services and life cycle management for all other Jetty server components. 
In the standard Jetty distribution, the core server configuration is in `etc/jetty.xml` file, but you can mix in other server configurations which can include:

ThreadPool::
  The Server instance provides a ThreadPool instance that is the default Executor service other Jetty server components use. 
  The prime configuration of the thread pool is the maximum and minimum size and is set in `start.ini` or `start.d/server.ini`.
Handlers::
  A Jetty server can have only a single Handler instance to handle incoming HTTP requests. 
  However a handler may be a container or wrapper of other handlers forming a tree of handlers that typically
  handle a request as a collaboration between the handlers from a branch of the tree from root to leaf. 
  The default handler tree set up in the `etc/jetty.xml` file is a Handler Collection containing a Context Handler Collection and the Default Handler. 
  The Context Handler Collection selects the next handler by context path and is where deployed Context Handler and Web Application Contexts are added to the handler tree. 
  The Default Handler handles any requests not already handled and generates the standard 404 page. 
  Other configuration files may add handlers to this tree (for example, `jetty-rewrite.xml`, `jetty-requestlog.xml`) or configure components to hot deploy handlers (for example, `jetty-deploy.xml`).
Server Attributes::
  The server holds a generic attribute map of strings to objects so that other Jetty components can associate named objects with the server, and if the value objects implement the LifeCycle interface, they are started and stopped with the server. 
  Typically server attributes hold server-wide default values.
Server fields::
  The server also has some specific configuration fields that you set in `start.ini`  or `start.d/server.ini` for controlling, among other things, the sending of dates and versions in HTTP responses.
Connectors::
  The server holds a collection of connectors that receive connections for HTTP and the other protocols that Jetty supports. 
  The next section, xref:intro-jetty-configuration-connectors[] describes configuration of the connectors themselves. 
  For the server you can either set the collection of all connectors or add/remove individual connectors.
Services::
  The server can hold additional service objects, sometimes as attributes, but often as aggregated LifeCycle beans.
  Examples of services are Login Services and DataSources, which you configure at the server level and then inject into the web applications that use them.

[[intro-jetty-configuration-connectors]]
==== Configuring Connectors

A Jetty Server Connector is a network end point that accepts connections for one or more protocols which produce requests and/or messages for the Jetty server. 
In the standard Jetty server distribution, several provided configuration files add connectors to the server for various protocols and combinations of protocols: `http.ini`, `https.ini` and `jetty-http2.xml`.
The configuration needed for connectors is typically:

Port::
  The TCP/IP port on which the connector listens for connections is set using the the XML Property element which looks up the `jetty.http.port` (or `jetty.ssl.port`) property, and if not found defaults to 8080 (or 8443 for TLS).
Host::
  You can configure a host either as a host name or IP address to identify a specific network interface on which to listen.
  If not set, or set to the value of 0.0.0.0, the connector listens on all local interfaces. 
  The XML Property element is used to look up the host value from the `jetty.host` property.
Idle Timeout::
  The time in milliseconds that a connection can be idle before the connector takes action to close the connection.
HTTP Configuration::
  Connector types that accept HTTP semantics (including HTTP, HTTPS and HTTP2) are configured with a `HttpConfiguration` instance that contains common HTTP configuration that is independent of the specific wire protocol used. 
  Because these values are often common to multiple connector types, the standard Jetty Server distribution creates a single `HttpConfiguration` in the `jetty.xml` file which is used via the XML Ref element in the specific connector files.
SSL Context Factory::
  The TLS connector types (HTTPS and HTTP2) configure an SSL Context Factory with the location of the server keystore and truststore for obtaining server certificates.


____
[NOTE]
Virtual hosts are not configured on connectors. You must configure individual contexts with the virtual hosts to which they respond.
____

____
[NOTE]
Prior to Jetty 9, the type of the connector reflected both the protocol supported (HTTP, HTTPS, AJP, SPDY), and the nature of the implementation (NIO or BIO). 
From Jetty 9 onwards there is only one prime Connector type (`ServerConnector`), which is NIO based and uses Connection Factories to handle one or more protocols.
____

[[intro-jetty-configuration-contexts]]
==== Configuring Contexts

A Jetty context is a handler that groups other handlers under a context path together with associated resources and is roughly equivalent to the standard ServletContext API. 
A context may contain either standard Jetty handlers or a custom application handler.

____
[NOTE]
The servlet specification defines a web application. 
In Jetty a standard web application is a specialized context that uses a standard layout and `WEB-INF/web.xml` to instantiate and configure classpath, resource base and handlers for sessions, security, and servlets, plus servlets for JSPs and static content. 
Standard web applications often need little or no additional configuration, but you can also use the techniques for arbitrary contexts to refine or modify the configuration of standard web applications.
____

Configuration values that are common to all contexts are:

contextPath::
  The contextPath is a URL prefix that identifies which context a HTTP request is destined for. 
  For example, if a context has a context path `/foo`, it handles requests to `/foo`, `/foo/index.html`,
  `/foo/bar/`, and `/foo/bar/image.png` but it does not handle requests like `/`, `/other/`, or `/favicon.ico`. 
  A context with a context path of / is called the root context.
+
The context path can be set by default from the deployer (which uses the filename as the basis for the context path); or in code; or it can be set by a Jetty IoC XML that is either applied by the deployer or found in the `WEB-INF/jetty-web.xml` file of a standard web app context.

virtualHost::
  A context may optionally have one or more virtual hosts set. 
  Unlike the host set on a connector (which selects the network interface on which to listen), a virtual host does not set any network parameters.
  Instead a virtual host represents an alias assigned by a name service to an IP address, which may have many aliases. 
  To determine which virtual host a request is intended for, the HTTP client (browser) includes in the request the name used to look up the network address.
  A context with a virtual host set only handles requests that have a matching virtual host in their request headers.
classPath::
  A context may optionally have a classpath, so that any thread that executes a handler within the context has a thread context classloader set with the classpath. 
  A standard web application has the classpath initialized by the `WEB-INF/lib` and `WEB-INF/classes` directory and
  has additional rules about delegating classloading to the parent classloader. 
  All contexts may have additional classpath entries added.
attributes::
  Attributes are arbitrary named objects that are associated with a context and are frequently used to pass entities between a web application and its container. 
  For example the attribute `javax.servlet.context.tempdir` is used to pass the File instance that represents the assigned temporary directory for a web application.
resourceBase::
  The resource base is a directory (or collection of directories or URL) that contains the static resources for the context. 
  These can be images and HTML files ready to serve or JSP source files ready to be compiled. 
  In traditional web servers this value is often called the docroot.

===== Context Configuration by API

In an embedded server, you configure contexts by directly calling the link:{JDURL}/org/eclipse/jetty/server/handler/ContextHandler.html[ContextHandler] API as in the following example:

[source, java, subs="{sub-order}"]
----
include::{SRCDIR}/examples/embedded/src/main/java/org/eclipse/jetty/embedded/OneContext.java[]
----

===== Context Configuration by IoC XML

You can create and configure a context entirely by IoC XML (either Jetty's or Spring). 
The deployer discovers and hot deploys context IoC descriptors like the following which creates a context to serve the Javadoc from the Jetty distribution:

[source, xml, subs="{sub-order}"]
----
<?xml version="1.0"  encoding="UTF-8"?>
<!DOCTYPE Configure PUBLIC
    "-//Mort Bay Consulting//DTD Configure//EN"
    "http://www.eclipse.org/jetty/configure_9_3.dtd">

<!--
  Configure a custom context for serving javadoc as static resources
-->

<Configure class="org.eclipse.jetty.server.handler.ContextHandler">
  <Set name="contextPath">/javadoc</Set>
  <Set name="resourceBase"><SystemProperty name="jetty.home" default="."/>/javadoc/</Set>
  <Set name="handler">
    <New class="org.eclipse.jetty.server.handler.ResourceHandler">
      <Set name="welcomeFiles">
        <Array type="String">
          <Item>index.html</Item>
        </Array>
      </Set>
      <Set name="cacheControl">max-age=3600,public</Set>
    </New>
  </Set>
</Configure>
----

[[intro-jetty-configuration-webapps]]
===== Configuring Web Applications

The servlet specification defines a web application, which when packaged as a zip is called WAR file (Web application ARchive). 
Jetty implements both WAR files and unpacked web applications as a specialized context that is configured by means of:

* A standard layout which sets the location of the resourceBase (the root of the WAR) and initializes the classpath from jars found in `WEB-INF/lib` and classes found in `WEB-INF/classes`.
* The standard `WEB-INF/web.xml` deployment descriptor which is parsed to define and configure init parameters, filters, servlets, listeners, security constraints, welcome files and resources to be injected.
* A default `web.xml` format deployment descriptor provided either by Jetty or in configuration configures the JSP servlet and the default servlet for handling static content. 
The standard `web.xml` may override the default `web.xml`.
* Annotations discovered on classes in Jars contained in `WEB-INF/lib` can declare additional filters, servlets and listeners.
* Standard deployment descriptor fragments discovered in Jars contained in `WEB-INF/lib` can declare additional init parameters, filters, servlets, listeners, security constraints, welcome files and resources to be injected.
* An optional `WEB-INF/jetty-web.xml` file may contain Jetty IoC configuration to configure the Jetty specific APIs of the context and handlers.

Because these configuration mechanisms are contained within the WAR file (or unpacked web application), typically a web application contains much of its own configuration and deploying a WAR is often just a matter of dropping the WAR file in to the webapps directory that is scanned by the link:#quickstart-config-deployer[Jetty deployer].

If you need to configure something within a web application, often you do so by unpacking the WAR file and editing the `web.xml` and other configuration files. 
However, both the servlet standard and some Jetty features allow for other configuration to be applied to a web application externally from the WAR:

* Configured data sources and security realms in the server can be injected into a web application either explicitly or by name matching.
* Jetty allows one or more override deployment descriptors, in `web.xml` format, to be set on a context (via code or IoC XML) to amend the configuration set by the default and standard `web.xml`.
* The normal Jetty Java API may be called by code or IoC XML to amend the configuration of a web application.

===== Setting the Context Path

The web application standard provides no configuration mechanism for a web application or WAR file to set its own `contextPath`. 
By default the deployer uses conventions to set the context path: 
If you deploy a WAR file called `foobar.WAR`, the context path is `/foobar`; if you deploy a WAR file called `ROOT.WAR` the context path is `/`. 

However, it is often desirable to explicitly set the context path so that information (for example, version numbers) may be included in the filename of the WAR.
Jetty allows the context Path of a WAR file to be set internally (by the WAR itself) or externally (by the deployer of the WAR).

To set the contextPath from within the WAR file, you can include a `WEB-INF/jetty-web.xml` file which contains IoC XML to set the context path:

[source, xml, subs="{sub-order}"]
----
<?xml version="1.0"  encoding="UTF-8"?>
<!DOCTYPE Configure PUBLIC
    "-//Mort Bay Consulting//DTD Configure//EN"
    "http://www.eclipse.org/jetty/configure_9_3.dtd">

<Configure class="org.eclipse.jetty.webapp.WebAppContext">
    <Set name="contextPath">/contextpath</Set>
</Configure>
----

Alternately, you can configure the classpath externally without the need to modify the WAR file itself.
Instead of allowing the WAR file to be discovered by the deployer, an IoC XML file may be deployed that both sets the context path and declares the WAR file that it applies to:

[source, xml, subs="{sub-order}"]
----
<?xml version="1.0"  encoding="UTF-8"?>
<!DOCTYPE Configure PUBLIC
    "-//Mort Bay Consulting//DTD Configure//EN"
    "http://www.eclipse.org/jetty/configure_9_3.dtd">

<Configure class="org.eclipse.jetty.webapp.WebAppContext">
  <Set name="war"><SystemProperty name="jetty.home" default="."/>/webapps/test.war</Set>
  <Set name="contextPath">/test</Set>
</Configure>
----

An example of setting the context path is included with the Jetty distribution in `$JETTY_HOME/webapps/test.xml`.

[[quickstart-config-deployer]]
===== Web Application Deployment

Jetty is capable of deploying a variety of Web Application formats. 
This is accomplished via scans of the `${jetty.base}/webapps` directory for contexts to deploy.

A Context can be any of the following:

* A standard WAR file. (must in "`.war`").
* A directory containing an expanded WAR file. (must contain `{dir}/WEB-INF/web.xml` file).
* A directory containing static content.
* A XML descriptor in xref:jetty-xml-syntax[] that configures a link:{JDURL}/org/eclipse/jetty/server/handler/ContextHandler.html[ContextHandler] instance (Such as a
link:{JDURL}/org/eclipse/jetty/webapp/WebAppContext.html[WebAppContext]).

The new WebAppProvider will attempt to avoid double deployments during the directory scan with the following heuristics:

* Hidden files (starting with `"."`) are ignored
* Directories with names ending in `".d"` are ignored
* If a directory and matching WAR file exist with the same base name (eg: `foo/` and `foo.war`), then the directory is assumed to be the unpacked WAR and only the WAR is deployed (which may reuse the unpacked directory)
* If a directory and matching XML file exists (eg: `foo/` and `foo.xml`), then the directory is assumed to be an unpacked WAR and only the XML is deployed (which may use the directory in its own configuration)
* If a WAR file and matching XML file exist (eg: `foo.war` and `foo.xml`), then the WAR is assumed to be configured by the XML and only the XML is deployed.

____
[NOTE]
In prior versions of Jetty there was a separate ContextDeployer that provided XML-based deployment. As of Jetty 9 the ContextDeployer no longer exists and its functionality has been merged with the new link:{JDURL}/org/eclipse/jetty/deploy/providers/WebAppProvider.html[WebAppProvider] to avoid double deployment scenarios.
____

//A Context is an instance of ContextHandler that aggregates other handlers with common resources for handling HTTP requests (such as resource base, class loader, configuration attributes). 
//A standard web application is a specialized instance of a context (called a WebAppContext) that uses standard layouts and `web.xml` deployment descriptors to configure the context.

===== Setting an Authentication Realm

The authentication method and realm name for a standard web application may be set in the `web.xml` deployment descriptor with elements like:

[source, xml, subs="{sub-order}"]
----
...
<login-config>
  <auth-method>BASIC</auth-method>
  <realm-name>Test Realm</realm-name>
</login-config>
...
----

This example declares that the BASIC authentication mechanism will be used with credentials validated against a realm called "Test Realm."
However the standard does not describe how the realm itself is implemented or configured. 
In Jetty, there are several realm implementations (called LoginServices) and the simplest of these is the HashLoginService, which can read usernames and credentials from a Java properties file.

To configure an instance of HashLoginService that matches the "Test Realm" configured above, the following `$JETTY_BASE/etc/test-realm.xml` IoC XML file should be passed on the command line or set in `start.ini` or `start.d/server.ini`.

[source, xml, subs="{sub-order}"]
----
include::{SRCDIR}/tests/test-webapps/test-jetty-webapp/src/main/config/demo-base/etc/test-realm.xml[]
----

This creates and configures the LoginService as an aggregate bean on the server. 
When a web application is deployed that declares a realm called "Test Realm," the server beans are searched for a matching Login Service.
